plot(PCA_tasa_IPC33$scores[,4],type="l",ylab="PC4")##Patrones periódicos
plot(PCA_tasa_IPC33$scores[,5],type="l",ylab="PC5")
plot(PCA_tasa_IPC33$scores[,6],type="l",ylab="PC6")##Patrones periódicos
acf(PCA_tasa_IPC33$scores)
acf(PCA_tasa_IPC33$scores[,1:10])
x11()
acf(PCA_tasa_IPC33$scores[,1:10])
x11()
x11()
acf(PCA_tasa_IPC33$scores[,1:10])
library(factoextra)
install.packages("factoextra")
library(factoextra)
fviz_eig(PCA_tasa_IPC33$sdev)
fviz_eig(PCA_tasa_IPC33)
fviz_pca_var(PCA_tasa_IPC33,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE     # Avoid text overlapping
)
fviz_pca_var(PCA_tasa_IPC33,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE     # Avoid text overlapping
)
CPIEurope200015
plot(IPC33)
length(monthly_index)
plot(log_IPC33)
PCA_log_IPC33=princomp(as.matrix(log_IPC33))
as.matrix(log_IPC33)
names(PCA_log_IPC33)
plot(1:33,PCA_log_IPC33$sdev^2,xlab="Componente",ylab="Varianza",pch="op",main="log IPC 33")  ###Varianza por componente
plot(1:33,cumsum(PCA_log_IPC33$sdev^2)/cumsum(PCA_log_IPC33$sdev^2)[33],xlab="Componente",ylab="Varianza Acumulada",pch="op",main="log IPC 33")###Proporción acumulada por componente
PCA_log_IPC33$scores   ###Componentes principales
x11()
par(mfrow = c(3 , 2))
plot(PCA_log_IPC33$scores[,1],type="l",ylab="PC1") ###Tendencia creciente
plot(PCA_log_IPC33$scores[,2],type="l",ylab="PC2")##Tendencia, pero no necesariamente monótona
plot(PCA_log_IPC33$scores[,3],type="l",ylab="PC3")##Tendencia, pero no necesariamente monótona
plot(PCA_log_IPC33$scores[,4],type="l",ylab="PC4")##Patrones periódicos
plot(PCA_log_IPC33$scores[,5],type="l",ylab="PC5")
plot(PCA_log_IPC33$scores[,6],type="l",ylab="PC6")##Patrones periódicos
x11()
par(mfrow = c(3 , 2))
plot(PCA_log_IPC33$scores[,7],type="l") ###Tendencia creciente
plot(PCA_log_IPC33$scores[,8],type="l")##Tendencia, pero no necesariamente monótona
plot(PCA_log_IPC33$scores[,9],type="l")##Tendencia, pero no necesariamente monótona
plot(PCA_log_IPC33$scores[,10],type="l")##Patrones periódicos
plot(PCA_log_IPC33$scores[,11],type="l")
plot(PCA_log_IPC33$scores[,12],type="l")##Patrones periódicos
x_t=diff(log_IPC33)[2:190,]   ###tasa de inflación con respecto al mes anterior
plot(x_t)
PCA_tasa_IPC33=princomp(as.matrix(x_t))
plot(1:33,PCA_tasa_IPC33$sdev^2,xlab="Componente",ylab="Varianza",pch="op",main="Tasa IPC 33")
PCA_tasa_IPC33$sdev
plot(1:33,cumsum(PCA_tasa_IPC33$sdev^2)/cumsum(PCA_tasa_IPC33$sdev^2)[33],xlab="Componente",ylab="Proporción Acumulada",pch="op",main="Tasa IPC 33")
x11()
par(mfrow = c(3 , 2))
plot(PCA_tasa_IPC33$scores[,1],type="l",ylab="PC1") ###No Tendencia,pero si patrones estacionales.
plot(PCA_tasa_IPC33$scores[,2],type="l",ylab="PC2")
plot(PCA_tasa_IPC33$scores[,3],type="l",ylab="PC3")
plot(PCA_tasa_IPC33$scores[,4],type="l",ylab="PC4")
plot(PCA_tasa_IPC33$scores[,5],type="l",ylab="PC5")
plot(PCA_tasa_IPC33$scores[,6],type="l",ylab="PC6")
x11()
fviz_pca_var(PCA_tasa_IPC33,
col.var = "contrib", # Color by contributions to the PC
gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
repel = TRUE     # Avoid text overlapping
)
x11()
acf(PCA_tasa_IPC33$scores[,1:5])
install.packages("odpc")
knitr::opts_chunk$set(echo = TRUE)
require(odpc)
?odpc
require(odpc)
UMEdata = read.csv("UME20002018.csv", header=TRUE)
x=as.matrix(UMEdata)
n=nrow(x)
G=matrix(0,n,19)
for (i in 1:19){G[,i]=x[,1+3*(i-1)]}
G0=log(G)
sG0=scale(G0)
G1=diff(sG0)
y1 <- range(G1)
tdx <- c(2:76)/4+2000
plot(tdx,G1[,1],xlab="año",ylab="Tasa de Crecimiento PIB", main="Países Euro",type="l", ylim=y1)
for (i in 2:19){lines(tdx,G1[,i],col=i)}
sal<- odpc(G1, ks=c(3,3))   ####en ks la primera componente es el número de retardos usados para definir la componente prinicpal dinámica
###La segunda componentees el número de retardos de la cla componente principal usada para reconstruir la serie. Puede ser una matriz,
###Cada fila indicará los retardos usados para cada componente principal
sal
matrix(c(3,3,3,3,3,3),3,3)
matrix(c(3,3,3,3,3,3),3,2)
sal<- odpc(G1, ks=matrix(c(3,3,3,3,3,3),3,2))   ####en ks la primera componente es el número de retardos usados para definir la componente prinicpal dinámica
sal
crit.odpc(G1,k_list = 1:5,
max_num_comp = 5)
salida=crit.odpc(G1,k_list = 1:5,
max_num_comp = 5)
salida
salida
### Cross-Validation
salida_IC_cv=cv.odpc(G1,k_list = 1:5,h=1,
max_num_comp = 5)
### Cross-Validation
salida_IC_cv=cv.odpc(G1,k_list = 1:5,h=1,
max_num_comp = 5)
### Cross-Validation
salida_IC_cv=cv.odpc(G1,k_list = 1:5,h=1,
max_num_comp =
5)
```
### Cross-Validation
salida_cv=cv.odpc(G1,h=1,k_list = 1:5,
max_num_comp = 5)
salida_cv
matrix(c(2,2,4,4),2,3)
sal<- odpc(G1, ks=matrix(c(2,2,4,4),2,2))   ### Por defecto hace 2
sal<- odpc(G1, ks=matrix(c(2,2,4,4),2,2))   ### Por defecto calcula dos componentes principales
sal
matrix(c(2,4,2,4),2,2)
sal<- odpc(G1, ks=matrix(c(2,4,2,4),2,2))   ### Por defecto calcula dos componentes principales
sal
f1<- sal[[1]]$f
a1<- sal[[1]]$a
f2<- sal[[2]]$f
a2<- sal[[2]]$a
sal<- odpc(G1, ks=matrix(c(2,4,2,4),2,2))   ### Por defecto calcula dos componentes principales
sal
f1<- sal[[1]]$f####DPC 1
a1<- sal[[1]]$a  ###Vector a para obtener la PC1
f2<- sal[[2]]$f ####DPC 2
a2<- sal[[2]]$a ###Vector a para obtener la PC2
B1 <- sal[[1]]$B ###Vector de B para obtener la reconstrucción
B2 <- sal[[2]]$B ###Vector de B para obtener la reconstrucción
y1 <- range(f1)
tdx <- c(5:76)/4+2000
plot(tdx,-f1,xlab="year",ylab="PC1", main="Primer PC
Países Euro", type="l", ylim=y1)
y1
tdx
length(tdx)
leangth(f1)
length(f1)
tdx <- c(4:76)/4+2000
plot(tdx,-f1,xlab="year",ylab="PC1", main="Primer PC
Países Euro", type="l", ylim=y1)
plot(tdx,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y1)
f2
length(f2)
length(tdx)
tdx2 <- c(5:76)/4+2000
plot(tdx2,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y1)
tdx2 <- c(6:76)/4+2000
plot(tdx2,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y1)
y1 <- range(f1)
tdx1 <- c(4:76)/4+2000
tdx2 <- c(6:76)/4+2000
plot(tdx1,-f1,xlab="year",ylab="PC1", main="Primer PC
Países Euro", type="l", ylim=y1)
plot(tdx2,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y1)
y1 <- range(-f1)
tdx1 <- c(4:76)/4+2000
tdx2 <- c(6:76)/4+2000
plot(tdx1,-f1,xlab="year",ylab="PC1", main="Primer PC
Países Euro", type="l", ylim=y1)
plot(tdx2,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y1)
y1 <- range(f1)
y1
y1 <- range(f1)*2
tdx1 <- c(4:76)/4+2000
tdx2 <- c(6:76)/4+2000
plot(tdx1,-f1,xlab="year",ylab="PC1", main="Primer PC
Países Euro", type="l", ylim=y1)
plot(tdx2,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y1)
y1 <- range(f1)*2
tdx1 <- c(4:76)/4+2000
tdx2 <- c(6:76)/4+2000
plot(tdx1,-f1,xlab="year",ylab="PC1", main="Primer PC
Países Euro", type="l", ylim=y1)
plot(tdx2,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y1)
y1 <- range(f1)*2
tdx1 <- c(4:76)/4+2000
tdx2 <- c(6:76)/4+2000
plot(tdx1,-f1,xlab="year",ylab="PC1", main="Primer PC
Países Euro", type="l", ylim=y1)
plot(tdx2,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y1)
y1 <- range(f1)*3
tdx1 <- c(4:76)/4+2000
tdx2 <- c(6:76)/4+2000
plot(tdx1,-f1,xlab="year",ylab="PC1", main="Primer PC
Países Euro", type="l", ylim=y1)
plot(tdx2,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y1)
y1 <- range(f1)*3
tdx1 <- c(4:76)/4+2000
tdx2 <- c(6:76)/4+2000
plot(tdx1,-f1,xlab="year",ylab="PC1", main="Primer PC
Países Euro", type="l", ylim=y1)
plot(tdx2,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y1)
y2<- range(f2)
sal<- odpc(G1, ks=matrix(c(2,4,2,4),2,2))   ### Por defecto calcula dos componentes principales
sal
f1<- sal[[1]]$f####DPC 1
a1<- sal[[1]]$a  ###Vector a para obtener la PC1
f2<- sal[[2]]$f ####DPC 2
a2<- sal[[2]]$a ###Vector a para obtener la PC2
B1 <- sal[[1]]$B ###Vector de B para obtener la reconstrucción
B2 <- sal[[2]]$B ###Vector de B para obtener la reconstrucción
y1 <- range(f1)
y2<- range(f2)
tdx1 <- c(4:76)/4+2000
tdx2 <- c(6:76)/4+2000
plot(tdx1,-f1,xlab="year",ylab="PC1", main="Primer PC
Países Euro", type="l", ylim=y1)
plot(tdx2,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y2)
y1
y2
y1 <- range(f1)+c(-1,1)
y2<- range(f2)+c(-1,1)
tdx1 <- c(4:76)/4+2000
sal<- odpc(G1, ks=matrix(c(2,4,2,4),2,2))   ### Por defecto calcula dos componentes principales
sal
f1<- sal[[1]]$f####DPC 1
a1<- sal[[1]]$a  ###Vector a para obtener la PC1
f2<- sal[[2]]$f ####DPC 2
a2<- sal[[2]]$a ###Vector a para obtener la PC2
B1 <- sal[[1]]$B ###Vector de B para obtener la reconstrucción
B2 <- sal[[2]]$B ###Vector de B para obtener la reconstrucción
y1 <- range(f1)+c(-1,1)
y2<- range(f2)+c(-1,1)
tdx1 <- c(4:76)/4+2000
tdx2 <- c(6:76)/4+2000
plot(tdx1,-f1,xlab="year",ylab="PC1", main="Primer PC
Países Euro", type="l", ylim=y1)
plot(tdx2,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y2)
sal<- odpc(G1, ks=matrix(c(2,4,2,4),2,2))   ### Por defecto calcula dos componentes principales
sal
f1<- sal[[1]]$f####DPC 1
a1<- sal[[1]]$a  ###Vector a para obtener la PC1
f2<- sal[[2]]$f ####DPC 2
a2<- sal[[2]]$a ###Vector a para obtener la PC2
B1 <- sal[[1]]$B ###Vector de B para obtener la reconstrucción
B2 <- sal[[2]]$B ###Vector de B para obtener la reconstrucción
y1 <- range(f1)+c(-1.5,1.5)
y2<- range(f2)+c(-1,1)
tdx1 <- c(4:76)/4+2000
tdx2 <- c(6:76)/4+2000
plot(tdx1,-f1,xlab="year",ylab="PC1", main="Primer PC
Países Euro", type="l", ylim=y1)
plot(tdx2,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y2)
sal<- odpc(G1, ks=matrix(c(2,4,2,4),2,2))   ### Por defecto calcula dos componentes principales
sal
f1<- sal[[1]]$f####DPC 1
a1<- sal[[1]]$a  ###Vector a para obtener la PC1
f2<- sal[[2]]$f ####DPC 2
a2<- sal[[2]]$a ###Vector a para obtener la PC2
B1 <- sal[[1]]$B ###Vector de B para obtener la reconstrucción
B2 <- sal[[2]]$B ###Vector de B para obtener la reconstrucción
y1 <- range(f1)+c(-1.5,0)
y2<- range(f2)+c(-0.5,0.5)
tdx1 <- c(4:76)/4+2000
tdx2 <- c(6:76)/4+2000
plot(tdx1,-f1,xlab="year",ylab="PC1", main="Primer PC
Países Euro", type="l", ylim=y1)
plot(tdx2,-f2,xlab="year",ylab="PC2", main="Secundo PC
Países Euro", type="l", ylim=y2)
a1
19*3
# A vector is split into its lags in order to plot them.
a10=a1[1:19]
a11=a1[20:38]
a12=a1[39:57]
#a13=a1[58:76]
par(mfrow=c(1,3))
plot(a10,xlab="Country",ylab="Lag 0 weight ", type="l")
plot(a11,xlab="Country",ylab="Lag 1 weight ", type="l")
plot(a12,xlab="Country",ylab="Lag 2 weight ", type="l")
#plot(a13,xlab="Country",ylab="Lag 3 weight ", type="l")
B1 <- sal[[1]]$B
B1
B1
install.packages(c("fGarch", "aTSA"))
#install.packages("fGarch")
#install.packages("aTSA")
library(fGarch)
library(aTSA)
library(forecast)
##ARCH(2)
###Específicar el modelo
###Simulación de la serie
set.seed(12)
spec = garchSpec(model = list(alpha = c(0.2, 0.4), beta = 0))
ARCH2=garchSim(spec, n = 500)
plot(ARCH2)
x11()
plot(ARCH2)
install.packages(c("nnfor", "tswge"))
knitr::opts_chunk$set(echo = TRUE)
library(astsa)
library(TSstudio)
data(chicken)
ts_info(chicken)
plot(chicken,main="Precio Mensual de la Libra de Pollo en Estados Unidos", ylab="Precio en Centavos de Dólar")
#ts_plot(chicken)
time(chicken)
summary(fit <- lm(chicken~time(chicken), na.action=NULL))
plot(chicken, ylab="centavos por libra")
abline(fit,col = "red") # Se añade la recta ajusta
ElimiTendchick=chicken-predict(fit)
plot(ElimiTendchick,main="Serie Chicken Sin tendencia")
summary(fit <- lm(chicken~time(chicken), na.action=NULL))
plot(chicken, ylab="centavos por libra")
abline(fit,col = "red") # Se añade la recta ajusta
###Eliminamos la tendencia con la predicción la recta
ElimiTendchick=chicken-predict(fit)
plot(ElimiTendchick,main="Serie Chicken Sin tendencia")
library(tidyverse)
library(lubridate)
library(timetk)
library(tsibble)
# Se configura para gráficas plotly(# FALSE retorna ggplots y no plotly)
interactive <- FALSE
indice_chicken=as.Date(as.yearmon(tk_index(chicken)))
library(TSstudio)
data(USUnRate)
ts_info(USUnRate)
plot(USUnRate,main = "US Monthly Unemployment Rate",ylab="Unemployment Rate (%)")
unemployment <- window(USUnRate, start = c(1990,1))
ts_plot(unemployment,
title = "US Monthly Unemployment Rate",
Ytitle = "Unemployment Rate (%)",
Xtitle = "Year",
Xgrid = TRUE,
Ygrid = TRUE)
library(readxl)
library(tidyverse)
DesempleoyEmpleo <- read_excel("DesempleoyEmpleo.xlsx", range="A9:C249")
str(DesempleoyEmpleo)
DesempleoyEmpleo_1=DesempleoyEmpleo %>% map_df(rev)
tail(DesempleoyEmpleo)
head(DesempleoyEmpleo_1)
library(zoo)
library(xts)
Fechas=as.yearmon(DesempleoyEmpleo_1$Fecha)
Desempleo_Col_xts=xts(x = DesempleoyEmpleo_1$Tasadedesempleo,frequency = 12,order.by = Fechas)
ts_info(Desempleo_Col_xts)
plot(Desempleo_Col_xts)
ts_plot(Desempleo_Col_xts,
title = "Tasa de Desemplo Mensual Colombia",
Ytitle = "Tasa de Desempleo(%)",
Xtitle = "Año",
Xgrid = TRUE,
Ygrid = TRUE)
require(feasts)
require(fable)
require(timetk)
require(tsibble)
###Creación objeto tssible a partir de un objeto tibble
df_desempleo=data.frame(Desempleo=DesempleoyEmpleo_1$Tasadedesempleo,Fecha=Fechas)
tbl_desempleo=tibble(df_desempleo)
tbl_desempleo_format_fecha=tbl_desempleo
tbl_desempleo_format_fecha$Fecha=yearmonth(tbl_desempleo_format_fecha$Fecha)
###El tipo de fechas debe ser alguno que reconozca tsibble
tsbl_desempleo=as_tsibble(tbl_desempleo_format_fecha,index=Fecha)   ####La fecha en tsibble es importante
##Gráfica de tsibble
autoplot(tsbl_desempleo,Desempleo)+labs(tittle="Serie de Desempleo Colombia Mensual",y="Tasa de Deszempleo")
###Gráfica timetk
tbl_desempleo%>%plot_time_series(.value=Desempleo,.date_var=Fecha)
library(tidyverse)
library(lubridate)
library(timetk)
library(tsibble)
# Se configura para gráficas plotly(# FALSE retorna ggplots y no plotly)
interactive <- FALSE
indice_chicken=as.Date(as.yearmon(tk_index(chicken)))
## Otra forma de extraer el indice estimetk::tk_index(chicken)
df_chicken=data.frame(Fecha=indice_chicken,Pollo=as.matrix(chicken))
str(df_chicken)
tibble_chicken=tibble(df_chicken)
duplicates(tibble_chicken, key = NULL, index=Fecha)   ##Mirar si hay registros duplicados
tibble_chicken_fechas_correct=tibble_chicken
tibble_chicken_fechas_correct$Fecha=yearmonth(tibble_chicken_fechas_correct$Fecha)
print(duplicates(tibble_chicken_fechas_correct, key = NULL, index=Fecha))
tsibble_chicken=tsibble(tibble_chicken_fechas_correct,index=Fecha)
tsibble_chicken
tibble_chicken%>%timetk::plot_time_series(Fecha, Pollo,
.interactive = interactive,
.plotly_slider = TRUE)
###Usa Loess para hacer el ajuste de la tendencia, es decir usar smooth_vec() como versión simplificada de stats::loess()
tibble_chicken%>%mutate(Pollo_ajus=smooth_vec(Pollo,span = 0.75, degree = 2))
tibble_chicken%>%mutate(Pollo_ajus=smooth_vec(Pollo,span = 0.5, degree = 1))%>%
ggplot(aes(Fecha, Pollo)) +
geom_line() +
geom_line(aes(y = Pollo_ajus), color = "red")
###Usa Loess para hacer el ajuste de la tendencia, es decir usar smooth_vec() como versión simplificada de stats::loess()
tibble_chicken%>%mutate(Pollo_ajus=smooth_vec(Pollo,span = 0.75, degree = 2))
tibble_chicken%>%mutate(Pollo_ajus=smooth_vec(Pollo,span = 0.5, degree = 1))%>%
ggplot(aes(Fecha, Pollo)) +
geom_line() +
geom_line(aes(y = Pollo_ajus), color = "red")
?smooth_vec
###Usa Loess para hacer el ajuste de la tendencia, es decir usar smooth_vec() como versión simplificada de stats::loess()
tibble_chicken%>%mutate(Pollo_ajus=smooth_vec(Pollo,span = 0.75, degree = 2))
chicken_decompo=decompose(chicken)
plot(chicken_decompo)
chicken_decompo$trend
y=ts(rnorm(1000,0,1),start=c(2000,01),frequency = 4)
plot(decompose(y))
library(TSstudio)
data(USUnRate)
ts_info(USUnRate)
plot(USUnRate,main = "US Monthly Unemployment Rate",ylab="Unemployment Rate (%)")
library(TSstudio)
data(USUnRate)
ts_info(USUnRate)
class(USUnRate)
plot(USUnRate,main = "US Monthly Unemployment Rate",ylab="Unemployment Rate (%)")
?ts_plot
unemployment <- window(USUnRate, start = c(1990,1))
ts_plot(unemployment,
title = "US Monthly Unemployment Rate",
Ytitle = "Unemployment Rate (%)",
Xtitle = "Year",
Xgrid = TRUE,
Ygrid = TRUE)
unemployment <- window(USUnRate, start = c(1990,1))
ts_plot(unemployment,
title = "US Monthly Unemployment Rate",
Ytitle = "Unemployment Rate (%)",
Xtitle = "Year",
Xgrid = TRUE,
Ygrid = TRUE)
library(readxl)
library(tidyverse)
DesempleoyEmpleo <- read_excel("DesempleoyEmpleo.xlsx", range="A9:C249")
str(DesempleoyEmpleo)
DesempleoyEmpleo_1=DesempleoyEmpleo %>% map_df(rev)
tail(DesempleoyEmpleo)
head(DesempleoyEmpleo_1)
library(zoo)
library(xts)
Fechas=as.yearmon(DesempleoyEmpleo_1$Fecha)
Desempleo_Col_xts=xts(x = DesempleoyEmpleo_1$Tasadedesempleo,frequency = 12,order.by = Fechas)
ts_info(Desempleo_Col_xts)
plot(Desempleo_Col_xts)
require(feasts)
require(fable)
require(timetk)
require(tsibble)
###Creación objeto tssible a partir de un objeto tibble
df_desempleo=data.frame(Desempleo=DesempleoyEmpleo_1$Tasadedesempleo,Fecha=Fechas)
tbl_desempleo=tibble(df_desempleo)
tbl_desempleo_format_fecha=tbl_desempleo
tbl_desempleo_format_fecha$Fecha=yearmonth(tbl_desempleo_format_fecha$Fecha)
###El tipo de fechas debe ser alguno que reconozca tsibble
tsbl_desempleo=as_tsibble(tbl_desempleo_format_fecha,index=Fecha)   ####La fecha en tsibble es importante
##Gráfica de tsibble
autoplot(tsbl_desempleo,Desempleo)+labs(tittle="Serie de Desempleo Colombia Mensual",y="Tasa de Deszempleo")
###Gráfica timetk
tbl_desempleo%>%plot_time_series(.value=Desempleo,.date_var=Fecha)
py$pasajeros
reticulate::repl_python()
py$data
py$data
library(ggplot2)
ggplot2::ggplot(data = py$data,aes(x=Month,y=NPassengers) )
py$data
library(ggplot2)
ggplot2::ggplot(data = py$data,aes(x=Month,y=NPassengers) )+geom_area()+geom_line()
py$data
library(ggplot2)
ggplot2::ggplot(data = py$data,aes(x=Month,y=NPassengers) )+geom_area()+geom_line()+theme_ipsum()
py$data
library(ggplot2)
ggplot2::ggplot(data = py$data,aes(x=Month,y=NPassengers) )+geom_line()
arreglo$dtype()
arreglo$shape()
arreglo$shape
data("AirPassengers")
plot(AirPassengers)
#####Transformación Box-Cox
library(FitAR)
library(forecast)
forecast::BoxCox.lambda(AirPassengers, method = "guerrero", lower = -1, upper = 3) ###Me entrega el valor de lambda
##method="loglik"
FitAR::BoxCox(AirPassengers)###Me entrega una gráfica
plot(forecast::BoxCox(AirPassengers,lambda=-0.294731))###
lAirPass=log(AirPassengers)
x11()
par(mar = c(1,1,1,1))
par(mfrow=c(2,1))
plot(AirPassengers,main="Serie de Pasajeros sin Transformar")
plot(lAirPass,main="Series con Transformación BoxCox")
##Box-Cox con timetk
timetk::box_cox_vec(AirPassengers,lambda = 'auto',silent = F)
reticulate::repl_python()
